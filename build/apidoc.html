<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/jhurliman/node-rate-limiter#readme"

    >limiter (v1.1.0)</a>
</h1>
<h4>A generic rate limiter for node.js. Useful for API clients, web crawling, or other tasks that need to be throttled</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter">module limiter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter">
            function <span class="apidocSignatureSpan">limiter.</span>RateLimiter
            <span class="apidocSignatureSpan">(tokensPerInterval, interval, fireImmediately)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter.prototype.getTokensRemaining">
            function <span class="apidocSignatureSpan">limiter.</span>RateLimiter.prototype.getTokensRemaining
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter.prototype.removeTokens">
            function <span class="apidocSignatureSpan">limiter.</span>RateLimiter.prototype.removeTokens
            <span class="apidocSignatureSpan">(count, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter.prototype.tryRemoveTokens">
            function <span class="apidocSignatureSpan">limiter.</span>RateLimiter.prototype.tryRemoveTokens
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket">
            function <span class="apidocSignatureSpan">limiter.</span>TokenBucket
            <span class="apidocSignatureSpan">(bucketSize, tokensPerInterval, interval, parentBucket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket.prototype.drip">
            function <span class="apidocSignatureSpan">limiter.</span>TokenBucket.prototype.drip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket.prototype.removeTokens">
            function <span class="apidocSignatureSpan">limiter.</span>TokenBucket.prototype.removeTokens
            <span class="apidocSignatureSpan">(count, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket.prototype.tryRemoveTokens">
            function <span class="apidocSignatureSpan">limiter.</span>TokenBucket.prototype.tryRemoveTokens
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">limiter.</span>RateLimiter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">limiter.</span>TokenBucket.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter.RateLimiter">module limiter.RateLimiter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter.RateLimiter">
            function <span class="apidocSignatureSpan">limiter.</span>RateLimiter
            <span class="apidocSignatureSpan">(tokensPerInterval, interval, fireImmediately)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter.RateLimiter.prototype">module limiter.RateLimiter.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>fireImmediately</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter.prototype.getTokensRemaining">
            function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>getTokensRemaining
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter.prototype.removeTokens">
            function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>removeTokens
            <span class="apidocSignatureSpan">(count, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter.prototype.tryRemoveTokens">
            function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>tryRemoveTokens
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>curIntervalStart</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>tokensThisInterval</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>tokenBucket</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter.RateLimiter.prototype.getTokensRemaining">module limiter.RateLimiter.prototype.getTokensRemaining</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter.prototype.getTokensRemaining.getTokensRemaining">
            function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>getTokensRemaining
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter.RateLimiter.prototype.removeTokens">module limiter.RateLimiter.prototype.removeTokens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter.prototype.removeTokens.removeTokens">
            function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>removeTokens
            <span class="apidocSignatureSpan">(count, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter.RateLimiter.prototype.tryRemoveTokens">module limiter.RateLimiter.prototype.tryRemoveTokens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.RateLimiter.prototype.tryRemoveTokens.tryRemoveTokens">
            function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>tryRemoveTokens
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter.TokenBucket">module limiter.TokenBucket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket.TokenBucket">
            function <span class="apidocSignatureSpan">limiter.</span>TokenBucket
            <span class="apidocSignatureSpan">(bucketSize, tokensPerInterval, interval, parentBucket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter.TokenBucket.prototype">module limiter.TokenBucket.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket.prototype.drip">
            function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>drip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket.prototype.removeTokens">
            function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>removeTokens
            <span class="apidocSignatureSpan">(count, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket.prototype.tryRemoveTokens">
            function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>tryRemoveTokens
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>bucketSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>content</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>interval</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>lastDrip</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>tokensPerInterval</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>parentBucket</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter.TokenBucket.prototype.drip">module limiter.TokenBucket.prototype.drip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket.prototype.drip.drip">
            function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>drip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter.TokenBucket.prototype.removeTokens">module limiter.TokenBucket.prototype.removeTokens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket.prototype.removeTokens.removeTokens">
            function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>removeTokens
            <span class="apidocSignatureSpan">(count, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.limiter.TokenBucket.prototype.tryRemoveTokens">module limiter.TokenBucket.prototype.tryRemoveTokens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.limiter.TokenBucket.prototype.tryRemoveTokens.tryRemoveTokens">
            function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>tryRemoveTokens
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter" id="apidoc.module.limiter">module limiter</a></h1>


    <h2>
        <a href="#apidoc.element.limiter.RateLimiter" id="apidoc.element.limiter.RateLimiter">
        function <span class="apidocSignatureSpan">limiter.</span>RateLimiter
        <span class="apidocSignatureSpan">(tokensPerInterval, interval, fireImmediately)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RateLimiter = function (tokensPerInterval, interval, fireImmediately) {
  this.tokenBucket = new TokenBucket(tokensPerInterval, tokensPerInterval,
    interval, null);

  // Fill the token bucket to start
  this.tokenBucket.content = tokensPerInterval;

  this.curIntervalStart = +new Date();
  this.tokensThisInterval = 0;
  this.fireImmediately = fireImmediately;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.RateLimiter.prototype.getTokensRemaining" id="apidoc.element.limiter.RateLimiter.prototype.getTokensRemaining">
        function <span class="apidocSignatureSpan">limiter.</span>RateLimiter.prototype.getTokensRemaining
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RateLimiter.prototype.getTokensRemaining = function () {
  this.tokenBucket.drip();
  return this.tokenBucket.content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.RateLimiter.prototype.removeTokens" id="apidoc.element.limiter.RateLimiter.prototype.removeTokens">
        function <span class="apidocSignatureSpan">limiter.</span>RateLimiter.prototype.removeTokens
        <span class="apidocSignatureSpan">(count, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RateLimiter.prototype.removeTokens = function (count, callback) {
  // Make sure the request isn&#x27;t for more than we can handle
  if (count &#x3e; this.tokenBucket.bucketSize) {
    process.nextTick(callback.bind(null, &#x27;Requested tokens &#x27; + count +
      &#x27; exceeds maximum tokens per interval &#x27; + this.tokenBucket.bucketSize,
      null));
    return false;
  }

  var self = this;
  var now = Date.now();

  // Advance the current interval and reset the current interval token count
  // if needed
  if (now - this.curIntervalStart &#x3e;= this.tokenBucket.interval) {
    this.curIntervalStart = now;
    this.tokensThisInterval = 0;
  }

  // If we don&#x27;t have enough tokens left in this interval, wait until the
  // next interval
  if (count &#x3e; this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
    if (this.fireImmediately) {
      process.nextTick(callback.bind(null, null, -1));
    } else {
      var waitInterval = Math.ceil(
        this.curIntervalStart + this.tokenBucket.interval - now);

      setTimeout(function() {
        self.tokenBucket.removeTokens(count, afterTokensRemoved);
      }, waitInterval);
    }
    return false;
  }

  // Remove the requested number of tokens from the token bucket
  return this.tokenBucket.removeTokens(count, afterTokensRemoved);

  function afterTokensRemoved(err, tokensRemaining) {
    if (err) return callback(err, null);

    self.tokensThisInterval += count;
    callback(null, tokensRemaining);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.RateLimiter.prototype.tryRemoveTokens" id="apidoc.element.limiter.RateLimiter.prototype.tryRemoveTokens">
        function <span class="apidocSignatureSpan">limiter.</span>RateLimiter.prototype.tryRemoveTokens
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RateLimiter.prototype.tryRemoveTokens = function (count) {
  // Make sure the request isn&#x27;t for more than we can handle
  if (count &#x3e; this.tokenBucket.bucketSize)
    return false;

  var now = Date.now();

  // Advance the current interval and reset the current interval token count
  // if needed
  if (now - this.curIntervalStart &#x3e;= this.tokenBucket.interval) {
    this.curIntervalStart = now;
    this.tokensThisInterval = 0;
  }

  // If we don&#x27;t have enough tokens left in this interval, return false
  if (count &#x3e; this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
    return false;

  // Try to remove the requested number of tokens from the token bucket
  return this.tokenBucket.tryRemoveTokens(count);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.TokenBucket" id="apidoc.element.limiter.TokenBucket">
        function <span class="apidocSignatureSpan">limiter.</span>TokenBucket
        <span class="apidocSignatureSpan">(bucketSize, tokensPerInterval, interval, parentBucket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TokenBucket = function (bucketSize, tokensPerInterval, interval, parentBucket) {
  this.bucketSize = bucketSize;
  this.tokensPerInterval = tokensPerInterval;

  if (typeof interval === &#x27;string&#x27;) {
    switch (interval) {
      case &#x27;sec&#x27;: case &#x27;second&#x27;:
        this.interval = 1000; break;
      case &#x27;min&#x27;: case &#x27;minute&#x27;:
        this.interval = 1000 * 60; break;
      case &#x27;hr&#x27;: case &#x27;hour&#x27;:
        this.interval = 1000 * 60 * 60; break;
      case &#x27;day&#x27;:
        this.interval = 1000 * 60 * 60 * 24; break;
    }
  } else {
    this.interval = interval;
  }

  this.parentBucket = parentBucket;
  this.content = 0;
  this.lastDrip = +new Date();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.TokenBucket.prototype.drip" id="apidoc.element.limiter.TokenBucket.prototype.drip">
        function <span class="apidocSignatureSpan">limiter.</span>TokenBucket.prototype.drip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TokenBucket.prototype.drip = function () {
  if (!this.tokensPerInterval) {
    this.content = this.bucketSize;
    return;
  }

  var now = +new Date();
  var deltaMS = Math.max(now - this.lastDrip, 0);
  this.lastDrip = now;

  var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
  this.content = Math.min(this.content + dripAmount, this.bucketSize);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.TokenBucket.prototype.removeTokens" id="apidoc.element.limiter.TokenBucket.prototype.removeTokens">
        function <span class="apidocSignatureSpan">limiter.</span>TokenBucket.prototype.removeTokens
        <span class="apidocSignatureSpan">(count, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TokenBucket.prototype.removeTokens = function (count, callback) {
  var self = this;

  // Is this an infinite size bucket?
  if (!this.bucketSize) {
    process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
    return true;
  }

  // Make sure the bucket can hold the requested number of tokens
  if (count &#x3e; this.bucketSize) {
    process.nextTick(callback.bind(null, &#x27;Requested tokens &#x27; + count + &#x27; exceeds bucket size &#x27; +
      this.bucketSize, null));
    return false;
  }

  // Drip new tokens into this bucket
  this.drip();

  // If we don&#x27;t have enough tokens in this bucket, come back later
  if (count &#x3e; this.content)
    return comeBackLater();

  if (this.parentBucket) {
    // Remove the requested from the parent bucket first
    return this.parentBucket.removeTokens(count, function(err, remainingTokens) {
      if (err) return callback(err, null);

      // Check that we still have enough tokens in this bucket
      if (count &#x3e; self.content)
        return comeBackLater();

      // Tokens were removed from the parent bucket, now remove them from
      // this bucket and fire the callback. Note that we look at the current
      // bucket and parent bucket&#x27;s remaining tokens and return the smaller
      // of the two values
      self.content -= count;
      callback(null, Math.min(remainingTokens, self.content));
    });
  } else {
    // Remove the requested tokens from this bucket and fire the callback
    this.content -= count;
    process.nextTick(callback.bind(null, null, this.content));
    return true;
  }

  function comeBackLater() {
    // How long do we need to wait to make up the difference in tokens?
    var waitInterval = Math.ceil(
      (count - self.content) * (self.interval / self.tokensPerInterval));
    setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.TokenBucket.prototype.tryRemoveTokens" id="apidoc.element.limiter.TokenBucket.prototype.tryRemoveTokens">
        function <span class="apidocSignatureSpan">limiter.</span>TokenBucket.prototype.tryRemoveTokens
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TokenBucket.prototype.tryRemoveTokens = function (count) {
  // Is this an infinite size bucket?
  if (!this.bucketSize)
    return true;

  // Make sure the bucket can hold the requested number of tokens
  if (count &#x3e; this.bucketSize)
    return false;

  // Drip new tokens into this bucket
  this.drip();

  // If we don&#x27;t have enough tokens in this bucket, return false
  if (count &#x3e; this.content)
    return false;

  // Try to remove the requested tokens from the parent bucket
  if (this.parentBucket &#x26;&#x26; !this.parent.tryRemoveTokens(count))
    return false;

  // Remove the requested tokens from this bucket and return
  this.content -= count;
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter.RateLimiter" id="apidoc.module.limiter.RateLimiter">module limiter.RateLimiter</a></h1>


    <h2>
        <a href="#apidoc.element.limiter.RateLimiter.RateLimiter" id="apidoc.element.limiter.RateLimiter.RateLimiter">
        function <span class="apidocSignatureSpan">limiter.</span>RateLimiter
        <span class="apidocSignatureSpan">(tokensPerInterval, interval, fireImmediately)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RateLimiter = function (tokensPerInterval, interval, fireImmediately) {
  this.tokenBucket = new TokenBucket(tokensPerInterval, tokensPerInterval,
    interval, null);

  // Fill the token bucket to start
  this.tokenBucket.content = tokensPerInterval;

  this.curIntervalStart = +new Date();
  this.tokensThisInterval = 0;
  this.fireImmediately = fireImmediately;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter.RateLimiter.prototype" id="apidoc.module.limiter.RateLimiter.prototype">module limiter.RateLimiter.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.limiter.RateLimiter.prototype.getTokensRemaining" id="apidoc.element.limiter.RateLimiter.prototype.getTokensRemaining">
        function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>getTokensRemaining
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensRemaining = function () {
  this.tokenBucket.drip();
  return this.tokenBucket.content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
To get the number of remaining tokens **outside** the `removeTokens`-callback
simply use the `getTokensRemaining`-method.
```javascript
var RateLimiter = require(&#x27;limiter&#x27;).RateLimiter;
var limiter = new RateLimiter(1, 250);

// returns 1 since we did not remove a token and our number of tokens per interval is 1
limiter.<span class="apidocCodeKeywordSpan">getTokensRemaining</span>();
```

Using the token bucket directly to throttle at the byte level:

```javascript
var BURST_RATE = 1024 * 1024 * 150; // 150KB/sec burst rate
var FILL_RATE = 1024 * 1024 * 50; // 50KB/sec sustained rate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.RateLimiter.prototype.removeTokens" id="apidoc.element.limiter.RateLimiter.prototype.removeTokens">
        function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>removeTokens
        <span class="apidocSignatureSpan">(count, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTokens = function (count, callback) {
  // Make sure the request isn&#x27;t for more than we can handle
  if (count &#x3e; this.tokenBucket.bucketSize) {
    process.nextTick(callback.bind(null, &#x27;Requested tokens &#x27; + count +
      &#x27; exceeds maximum tokens per interval &#x27; + this.tokenBucket.bucketSize,
      null));
    return false;
  }

  var self = this;
  var now = Date.now();

  // Advance the current interval and reset the current interval token count
  // if needed
  if (now - this.curIntervalStart &#x3e;= this.tokenBucket.interval) {
    this.curIntervalStart = now;
    this.tokensThisInterval = 0;
  }

  // If we don&#x27;t have enough tokens left in this interval, wait until the
  // next interval
  if (count &#x3e; this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
    if (this.fireImmediately) {
      process.nextTick(callback.bind(null, null, -1));
    } else {
      var waitInterval = Math.ceil(
        this.curIntervalStart + this.tokenBucket.interval - now);

      setTimeout(function() {
        self.tokenBucket.removeTokens(count, afterTokensRemoved);
      }, waitInterval);
    }
    return false;
  }

  // Remove the requested number of tokens from the token bucket
  return this.tokenBucket.removeTokens(count, afterTokensRemoved);

  function afterTokensRemoved(err, tokensRemaining) {
    if (err) return callback(err, null);

    self.tokensThisInterval += count;
    callback(null, tokensRemaining);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var RateLimiter = require(&#x27;limiter&#x27;).RateLimiter;
// Allow 150 requests per hour (the Twitter search limit). Also understands
// &#x27;second&#x27;, &#x27;minute&#x27;, &#x27;day&#x27;, or a number of milliseconds
var limiter = new RateLimiter(150, &#x27;hour&#x27;);

// Throttle requests
limiter.<span class="apidocCodeKeywordSpan">removeTokens</span>(1, function(err, remainingRequests) {
// err will only be set if we request more than the maximum number of
// requests we set in the constructor

// remainingRequests tells us how many additional requests could be sent
// right this moment

callMyRequestSendingFunction(...);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.RateLimiter.prototype.tryRemoveTokens" id="apidoc.element.limiter.RateLimiter.prototype.tryRemoveTokens">
        function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>tryRemoveTokens
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryRemoveTokens = function (count) {
  // Make sure the request isn&#x27;t for more than we can handle
  if (count &#x3e; this.tokenBucket.bucketSize)
    return false;

  var now = Date.now();

  // Advance the current interval and reset the current interval token count
  // if needed
  if (now - this.curIntervalStart &#x3e;= this.tokenBucket.interval) {
    this.curIntervalStart = now;
    this.tokensThisInterval = 0;
  }

  // If we don&#x27;t have enough tokens left in this interval, return false
  if (count &#x3e; this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
    return false;

  // Try to remove the requested number of tokens from the token bucket
  return this.tokenBucket.tryRemoveTokens(count);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A synchronous method, tryRemoveTokens(), is available in both RateLimiter and TokenBucket. This will return immediately with a boolean
 value indicating if the token removal was successful.
```javascript
var RateLimiter = require(&#x27;limiter&#x27;).RateLimiter;
var limiter = new RateLimiter(10, &#x27;second&#x27;);

if (limiter.<span class="apidocCodeKeywordSpan">tryRemoveTokens</span>(5))
  console.log(&#x27;Tokens removed&#x27;);
else
  console.log(&#x27;No tokens removed&#x27;);
```

To get the number of remaining tokens **outside** the `removeTokens`-callback
simply use the `getTokensRemaining`-method.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter.RateLimiter.prototype.getTokensRemaining" id="apidoc.module.limiter.RateLimiter.prototype.getTokensRemaining">module limiter.RateLimiter.prototype.getTokensRemaining</a></h1>


    <h2>
        <a href="#apidoc.element.limiter.RateLimiter.prototype.getTokensRemaining.getTokensRemaining" id="apidoc.element.limiter.RateLimiter.prototype.getTokensRemaining.getTokensRemaining">
        function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>getTokensRemaining
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensRemaining = function () {
  this.tokenBucket.drip();
  return this.tokenBucket.content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
To get the number of remaining tokens **outside** the `removeTokens`-callback
simply use the `getTokensRemaining`-method.
```javascript
var RateLimiter = require(&#x27;limiter&#x27;).RateLimiter;
var limiter = new RateLimiter(1, 250);

// returns 1 since we did not remove a token and our number of tokens per interval is 1
limiter.<span class="apidocCodeKeywordSpan">getTokensRemaining</span>();
```

Using the token bucket directly to throttle at the byte level:

```javascript
var BURST_RATE = 1024 * 1024 * 150; // 150KB/sec burst rate
var FILL_RATE = 1024 * 1024 * 50; // 50KB/sec sustained rate
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter.RateLimiter.prototype.removeTokens" id="apidoc.module.limiter.RateLimiter.prototype.removeTokens">module limiter.RateLimiter.prototype.removeTokens</a></h1>


    <h2>
        <a href="#apidoc.element.limiter.RateLimiter.prototype.removeTokens.removeTokens" id="apidoc.element.limiter.RateLimiter.prototype.removeTokens.removeTokens">
        function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>removeTokens
        <span class="apidocSignatureSpan">(count, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTokens = function (count, callback) {
  // Make sure the request isn&#x27;t for more than we can handle
  if (count &#x3e; this.tokenBucket.bucketSize) {
    process.nextTick(callback.bind(null, &#x27;Requested tokens &#x27; + count +
      &#x27; exceeds maximum tokens per interval &#x27; + this.tokenBucket.bucketSize,
      null));
    return false;
  }

  var self = this;
  var now = Date.now();

  // Advance the current interval and reset the current interval token count
  // if needed
  if (now - this.curIntervalStart &#x3e;= this.tokenBucket.interval) {
    this.curIntervalStart = now;
    this.tokensThisInterval = 0;
  }

  // If we don&#x27;t have enough tokens left in this interval, wait until the
  // next interval
  if (count &#x3e; this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
    if (this.fireImmediately) {
      process.nextTick(callback.bind(null, null, -1));
    } else {
      var waitInterval = Math.ceil(
        this.curIntervalStart + this.tokenBucket.interval - now);

      setTimeout(function() {
        self.tokenBucket.removeTokens(count, afterTokensRemoved);
      }, waitInterval);
    }
    return false;
  }

  // Remove the requested number of tokens from the token bucket
  return this.tokenBucket.removeTokens(count, afterTokensRemoved);

  function afterTokensRemoved(err, tokensRemaining) {
    if (err) return callback(err, null);

    self.tokensThisInterval += count;
    callback(null, tokensRemaining);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var RateLimiter = require(&#x27;limiter&#x27;).RateLimiter;
// Allow 150 requests per hour (the Twitter search limit). Also understands
// &#x27;second&#x27;, &#x27;minute&#x27;, &#x27;day&#x27;, or a number of milliseconds
var limiter = new RateLimiter(150, &#x27;hour&#x27;);

// Throttle requests
limiter.<span class="apidocCodeKeywordSpan">removeTokens</span>(1, function(err, remainingRequests) {
// err will only be set if we request more than the maximum number of
// requests we set in the constructor

// remainingRequests tells us how many additional requests could be sent
// right this moment

callMyRequestSendingFunction(...);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter.RateLimiter.prototype.tryRemoveTokens" id="apidoc.module.limiter.RateLimiter.prototype.tryRemoveTokens">module limiter.RateLimiter.prototype.tryRemoveTokens</a></h1>


    <h2>
        <a href="#apidoc.element.limiter.RateLimiter.prototype.tryRemoveTokens.tryRemoveTokens" id="apidoc.element.limiter.RateLimiter.prototype.tryRemoveTokens.tryRemoveTokens">
        function <span class="apidocSignatureSpan">limiter.RateLimiter.prototype.</span>tryRemoveTokens
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryRemoveTokens = function (count) {
  // Make sure the request isn&#x27;t for more than we can handle
  if (count &#x3e; this.tokenBucket.bucketSize)
    return false;

  var now = Date.now();

  // Advance the current interval and reset the current interval token count
  // if needed
  if (now - this.curIntervalStart &#x3e;= this.tokenBucket.interval) {
    this.curIntervalStart = now;
    this.tokensThisInterval = 0;
  }

  // If we don&#x27;t have enough tokens left in this interval, return false
  if (count &#x3e; this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
    return false;

  // Try to remove the requested number of tokens from the token bucket
  return this.tokenBucket.tryRemoveTokens(count);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A synchronous method, tryRemoveTokens(), is available in both RateLimiter and TokenBucket. This will return immediately with a boolean
 value indicating if the token removal was successful.
```javascript
var RateLimiter = require(&#x27;limiter&#x27;).RateLimiter;
var limiter = new RateLimiter(10, &#x27;second&#x27;);

if (limiter.<span class="apidocCodeKeywordSpan">tryRemoveTokens</span>(5))
  console.log(&#x27;Tokens removed&#x27;);
else
  console.log(&#x27;No tokens removed&#x27;);
```

To get the number of remaining tokens **outside** the `removeTokens`-callback
simply use the `getTokensRemaining`-method.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter.TokenBucket" id="apidoc.module.limiter.TokenBucket">module limiter.TokenBucket</a></h1>


    <h2>
        <a href="#apidoc.element.limiter.TokenBucket.TokenBucket" id="apidoc.element.limiter.TokenBucket.TokenBucket">
        function <span class="apidocSignatureSpan">limiter.</span>TokenBucket
        <span class="apidocSignatureSpan">(bucketSize, tokensPerInterval, interval, parentBucket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TokenBucket = function (bucketSize, tokensPerInterval, interval, parentBucket) {
  this.bucketSize = bucketSize;
  this.tokensPerInterval = tokensPerInterval;

  if (typeof interval === &#x27;string&#x27;) {
    switch (interval) {
      case &#x27;sec&#x27;: case &#x27;second&#x27;:
        this.interval = 1000; break;
      case &#x27;min&#x27;: case &#x27;minute&#x27;:
        this.interval = 1000 * 60; break;
      case &#x27;hr&#x27;: case &#x27;hour&#x27;:
        this.interval = 1000 * 60 * 60; break;
      case &#x27;day&#x27;:
        this.interval = 1000 * 60 * 60 * 24; break;
    }
  } else {
    this.interval = interval;
  }

  this.parentBucket = parentBucket;
  this.content = 0;
  this.lastDrip = +new Date();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter.TokenBucket.prototype" id="apidoc.module.limiter.TokenBucket.prototype">module limiter.TokenBucket.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.limiter.TokenBucket.prototype.drip" id="apidoc.element.limiter.TokenBucket.prototype.drip">
        function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>drip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drip = function () {
  if (!this.tokensPerInterval) {
    this.content = this.bucketSize;
    return;
  }

  var now = +new Date();
  var deltaMS = Math.max(now - this.lastDrip, 0);
  this.lastDrip = now;

  var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
  this.content = Math.min(this.content + dripAmount, this.bucketSize);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.TokenBucket.prototype.removeTokens" id="apidoc.element.limiter.TokenBucket.prototype.removeTokens">
        function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>removeTokens
        <span class="apidocSignatureSpan">(count, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTokens = function (count, callback) {
  var self = this;

  // Is this an infinite size bucket?
  if (!this.bucketSize) {
    process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
    return true;
  }

  // Make sure the bucket can hold the requested number of tokens
  if (count &#x3e; this.bucketSize) {
    process.nextTick(callback.bind(null, &#x27;Requested tokens &#x27; + count + &#x27; exceeds bucket size &#x27; +
      this.bucketSize, null));
    return false;
  }

  // Drip new tokens into this bucket
  this.drip();

  // If we don&#x27;t have enough tokens in this bucket, come back later
  if (count &#x3e; this.content)
    return comeBackLater();

  if (this.parentBucket) {
    // Remove the requested from the parent bucket first
    return this.parentBucket.removeTokens(count, function(err, remainingTokens) {
      if (err) return callback(err, null);

      // Check that we still have enough tokens in this bucket
      if (count &#x3e; self.content)
        return comeBackLater();

      // Tokens were removed from the parent bucket, now remove them from
      // this bucket and fire the callback. Note that we look at the current
      // bucket and parent bucket&#x27;s remaining tokens and return the smaller
      // of the two values
      self.content -= count;
      callback(null, Math.min(remainingTokens, self.content));
    });
  } else {
    // Remove the requested tokens from this bucket and fire the callback
    this.content -= count;
    process.nextTick(callback.bind(null, null, this.content));
    return true;
  }

  function comeBackLater() {
    // How long do we need to wait to make up the difference in tokens?
    var waitInterval = Math.ceil(
      (count - self.content) * (self.interval / self.tokensPerInterval));
    setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var RateLimiter = require(&#x27;limiter&#x27;).RateLimiter;
// Allow 150 requests per hour (the Twitter search limit). Also understands
// &#x27;second&#x27;, &#x27;minute&#x27;, &#x27;day&#x27;, or a number of milliseconds
var limiter = new RateLimiter(150, &#x27;hour&#x27;);

// Throttle requests
limiter.<span class="apidocCodeKeywordSpan">removeTokens</span>(1, function(err, remainingRequests) {
// err will only be set if we request more than the maximum number of
// requests we set in the constructor

// remainingRequests tells us how many additional requests could be sent
// right this moment

callMyRequestSendingFunction(...);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.limiter.TokenBucket.prototype.tryRemoveTokens" id="apidoc.element.limiter.TokenBucket.prototype.tryRemoveTokens">
        function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>tryRemoveTokens
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryRemoveTokens = function (count) {
  // Is this an infinite size bucket?
  if (!this.bucketSize)
    return true;

  // Make sure the bucket can hold the requested number of tokens
  if (count &#x3e; this.bucketSize)
    return false;

  // Drip new tokens into this bucket
  this.drip();

  // If we don&#x27;t have enough tokens in this bucket, return false
  if (count &#x3e; this.content)
    return false;

  // Try to remove the requested tokens from the parent bucket
  if (this.parentBucket &#x26;&#x26; !this.parent.tryRemoveTokens(count))
    return false;

  // Remove the requested tokens from this bucket and return
  this.content -= count;
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A synchronous method, tryRemoveTokens(), is available in both RateLimiter and TokenBucket. This will return immediately with a boolean
 value indicating if the token removal was successful.
```javascript
var RateLimiter = require(&#x27;limiter&#x27;).RateLimiter;
var limiter = new RateLimiter(10, &#x27;second&#x27;);

if (limiter.<span class="apidocCodeKeywordSpan">tryRemoveTokens</span>(5))
  console.log(&#x27;Tokens removed&#x27;);
else
  console.log(&#x27;No tokens removed&#x27;);
```

To get the number of remaining tokens **outside** the `removeTokens`-callback
simply use the `getTokensRemaining`-method.
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter.TokenBucket.prototype.drip" id="apidoc.module.limiter.TokenBucket.prototype.drip">module limiter.TokenBucket.prototype.drip</a></h1>


    <h2>
        <a href="#apidoc.element.limiter.TokenBucket.prototype.drip.drip" id="apidoc.element.limiter.TokenBucket.prototype.drip.drip">
        function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>drip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drip = function () {
  if (!this.tokensPerInterval) {
    this.content = this.bucketSize;
    return;
  }

  var now = +new Date();
  var deltaMS = Math.max(now - this.lastDrip, 0);
  this.lastDrip = now;

  var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
  this.content = Math.min(this.content + dripAmount, this.bucketSize);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter.TokenBucket.prototype.removeTokens" id="apidoc.module.limiter.TokenBucket.prototype.removeTokens">module limiter.TokenBucket.prototype.removeTokens</a></h1>


    <h2>
        <a href="#apidoc.element.limiter.TokenBucket.prototype.removeTokens.removeTokens" id="apidoc.element.limiter.TokenBucket.prototype.removeTokens.removeTokens">
        function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>removeTokens
        <span class="apidocSignatureSpan">(count, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTokens = function (count, callback) {
  var self = this;

  // Is this an infinite size bucket?
  if (!this.bucketSize) {
    process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
    return true;
  }

  // Make sure the bucket can hold the requested number of tokens
  if (count &#x3e; this.bucketSize) {
    process.nextTick(callback.bind(null, &#x27;Requested tokens &#x27; + count + &#x27; exceeds bucket size &#x27; +
      this.bucketSize, null));
    return false;
  }

  // Drip new tokens into this bucket
  this.drip();

  // If we don&#x27;t have enough tokens in this bucket, come back later
  if (count &#x3e; this.content)
    return comeBackLater();

  if (this.parentBucket) {
    // Remove the requested from the parent bucket first
    return this.parentBucket.removeTokens(count, function(err, remainingTokens) {
      if (err) return callback(err, null);

      // Check that we still have enough tokens in this bucket
      if (count &#x3e; self.content)
        return comeBackLater();

      // Tokens were removed from the parent bucket, now remove them from
      // this bucket and fire the callback. Note that we look at the current
      // bucket and parent bucket&#x27;s remaining tokens and return the smaller
      // of the two values
      self.content -= count;
      callback(null, Math.min(remainingTokens, self.content));
    });
  } else {
    // Remove the requested tokens from this bucket and fire the callback
    this.content -= count;
    process.nextTick(callback.bind(null, null, this.content));
    return true;
  }

  function comeBackLater() {
    // How long do we need to wait to make up the difference in tokens?
    var waitInterval = Math.ceil(
      (count - self.content) * (self.interval / self.tokensPerInterval));
    setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var RateLimiter = require(&#x27;limiter&#x27;).RateLimiter;
// Allow 150 requests per hour (the Twitter search limit). Also understands
// &#x27;second&#x27;, &#x27;minute&#x27;, &#x27;day&#x27;, or a number of milliseconds
var limiter = new RateLimiter(150, &#x27;hour&#x27;);

// Throttle requests
limiter.<span class="apidocCodeKeywordSpan">removeTokens</span>(1, function(err, remainingRequests) {
// err will only be set if we request more than the maximum number of
// requests we set in the constructor

// remainingRequests tells us how many additional requests could be sent
// right this moment

callMyRequestSendingFunction(...);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.limiter.TokenBucket.prototype.tryRemoveTokens" id="apidoc.module.limiter.TokenBucket.prototype.tryRemoveTokens">module limiter.TokenBucket.prototype.tryRemoveTokens</a></h1>


    <h2>
        <a href="#apidoc.element.limiter.TokenBucket.prototype.tryRemoveTokens.tryRemoveTokens" id="apidoc.element.limiter.TokenBucket.prototype.tryRemoveTokens.tryRemoveTokens">
        function <span class="apidocSignatureSpan">limiter.TokenBucket.prototype.</span>tryRemoveTokens
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryRemoveTokens = function (count) {
  // Is this an infinite size bucket?
  if (!this.bucketSize)
    return true;

  // Make sure the bucket can hold the requested number of tokens
  if (count &#x3e; this.bucketSize)
    return false;

  // Drip new tokens into this bucket
  this.drip();

  // If we don&#x27;t have enough tokens in this bucket, return false
  if (count &#x3e; this.content)
    return false;

  // Try to remove the requested tokens from the parent bucket
  if (this.parentBucket &#x26;&#x26; !this.parent.tryRemoveTokens(count))
    return false;

  // Remove the requested tokens from this bucket and return
  this.content -= count;
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A synchronous method, tryRemoveTokens(), is available in both RateLimiter and TokenBucket. This will return immediately with a boolean
 value indicating if the token removal was successful.
```javascript
var RateLimiter = require(&#x27;limiter&#x27;).RateLimiter;
var limiter = new RateLimiter(10, &#x27;second&#x27;);

if (limiter.<span class="apidocCodeKeywordSpan">tryRemoveTokens</span>(5))
  console.log(&#x27;Tokens removed&#x27;);
else
  console.log(&#x27;No tokens removed&#x27;);
```

To get the number of remaining tokens **outside** the `removeTokens`-callback
simply use the `getTokensRemaining`-method.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
